Welcome to CAB202’s supplementary videos for Assessment 2. Jackson and I have curated the following videos to help you get started with the project. In these videos, we will go through each of the functionality specifications and talk about how you might approach them using what we have taught you in the semester. I’ll then go over some general advice for writing code, so that you can avoid common pitfalls that we have seen in previous semesters. Jackson will then demo a completed version of the assignment on the QUTy board. Before we begin, please read over the specifications yourselves, and familiarise yourself with the Simon game. Also, make sure that you’ve watched the lecture videos up to Week 11, so that you understand how each of the peripherals discussed in those lectures can be used to complete this assignment. Complete at a minimum Tutorials 6 to 10, so that you know how to interface with these peripherals in C. To see how you might build a program similar to your assignment, complete Tutorials 11 and 12 also. These final two tutorials bring together what you have learnt in Weeks 6 through 10, allowing you to focus on writing a well-structured and efficient program. With that being said, we don’t want you to copy this code blindly, because many of these exercises are designed to be instructive. Instead, we want you to takeaway the key ideas and concepts that are relevant to this project. Secondly, remember that we will be marking you on code structure, neatness, and clarity. So, don’t immediately dump all the code that you think you might need from the tutorials, but instead work on one component at a time, adding code as you need. This will avoid many errors that we see every semester where students wrongly assume the code that they wrote for those tutorials is appropriate for the project. When you write your code make sure to make it presentable by doing the following. Remember that your code will be manually reviewed, and asking for help is easier when we can quickly identify what is going on. You should also try to make your program modular as you’ll see in Tutorials 11 and 12. Limit symbol visibility as much as you can. This means you should mark all global variables and functions as static, unless they must be accessed from another file. This isn’t meant to be a restriction, but rather a way to keep your code tidy and make it easier to debug. An example of this would be to turn on the buzzer with a function call, rather than having to manually set the value of the PER and CMP0 registers within the main function. If you’ve done CAB201 you might recall this diagram about coupling and cohesion. What we want is to keep coupling between files to a minimum and have tight cohesion within the same file. Don’t just create another file to split the contents of one very long file, but instead, split files into logical components. Something to keep in mind when working on this project, is that we are programming a microcontroller where we have complete control over the execution of instructions and want to produce predictable outcomes. Avoid adding unnecessary complexity or abstracting simple operations. Remove any error handling for functions that you wrote that you know will never fail, and make sure that you implement conditional logic correctly. Write clear and concise code that is easy to understand and debug, while also being efficient. What we’ve taught you in the tutorials is sufficient to complete this assignment, so avoid including additional libraries or code for heap allocations, software delays, or string manipulation. When you debug your code, please be very methodical and systematic. Don’t add or change code without any reason, as you might break code that was already working. Instead, isolate the problem and debug small sections of code at a time. This is also why we recommend that you focus on structuring your code well from the start, as this will make it easier to find errors. When adding new code, be very intentional about what you are adding, and make sure that you understand how it will affect the rest of your program. Finally, make sure to remove any printf statements or other debugging code when you have fixed an issue, as printf statements can slow down your program and cause it to behave differently than it would without them. So, where should you begin? Because all of these sections are interconnected, my recommendation is to begin with the components that are not dependent on anything else. So, this would be the random number generator in Section B, and interfacing with the buzzer and 7-segment display. Working on Section A requires you to produce outputs corresponding to the random values generated in Section B, so having functions to handle this will be useful. Here you should also confirm that your algorithm works by returning the first 8 steps corresponding to the default student ID, and comparing them with the example sequence that is shown on the task sheet. After this you should design a state machine and implement the gameplay mechanics. This will require you to handle pushbutton inputs, and compare these with the sequence of steps generated by Simon. Regarding Sections C and E, I would strongly recommend that you work on these after you have passed the gameplay tests, as they will unnecessarily complicate your program if you try to complete them at the same time, hindering progress in other tests. So just like any software development project, your aim is to make incremental changes to your program, and, if you look at the mark distribution, you’ll notice that most of the marks are allocated to the gameplay mechanics. So when you begin, you might want to make a file for the timer, and create a global variable for the playback delay, setting it equal to 250. You’ll see that I have designed all tests so that the potentiometer position is at 0, except for the playback delay tests themselves. When you get to the UART section, you’ll notice that gameplay inputs will be handled almost identically to pushbutton inputs, so try to design your state machine in a way that you can do all of this in the same section of code.

Once you have implemented the algorithm for generating random numbers, you should think about how you will sequence the steps played by Simon, and how you will then compare these steps with the user’s inputs. Keep in mind that the maximum score, or the maximum level the player can reach is 65535. A sequence of this length can’t be stored in memory, regardless of encoding or compression. Along with this, your program will need to handle the SEED command, which will override the initial value of the linear feedback shift register and produce a completely new sequence of steps. So, it’s not sensible to store the entire sequence of steps in RAM, or to compute it when your program starts. So how can we get around this limitation? Let’s look at the algorithm that we’re provided. In this algorithm, we can identify an input, which is the STATE_LFSR variable, and an output, which is the STEP variable. Notice that the MASK is constant and does not change. The algorithm also doesn’t access any other mutable state (so other global variables), so we can treat this as a “pure function”. This means that the output of the function is solely dependent on the input, and nothing else. So, if we know the initial state of the LFSR, we can predict the output of this algorithm at any iteration, allowing us to generate a sequence of infinite length, without needing to store it in memory. I’ll head over to some code to illustrate this more clearly. Let’s say our algorithm is implemented in this function, and it returns the value of the STEP variable. Then, what we want is, for the function to produce a sequence of 1 step in the first level. A sequence of 2 steps in the second level. And, a sequence of 3 steps in the third level. Assuming the player replays the sequence correctly. What your program should do is the following. In the first level, Simon should produce a single output corresponding to STEP = 1, wait for the user to press a button, and then check if the user’s input matches the output of the algorithm. Now the subsequent levels are slightly more complex. Here, Simon will produce two outputs, 1 and 2. Then, your program will need to compare user inputs as they come in, and check if they match the sequence produced by Simon. So you can see here that the user provides an input, and we make a comparison, and only proceed if the input is correct. Otherwise, we should end the game. And, for completeness, you can see that this also looks very similar for the third level as well. So what is happening to the LFSR when we go beyond the first level? Let’s say the user passes every level, and here I’ve denoted values of the LFSR with letters A through E, and the output of the algorithm with numbers 1 through 4. In the first level, calling the algorithm with LFSR = A produces the output 1 while also updating the LFSR to B. In the second level, notice how, to reproduce the sequence starting from 1, we need to call the algorithm with LFSR = A, and then when LFSR = B (because the algorithm mutates the LFSR), we can produce the second output by calling the algorithm again, giving us 2. We can do the same for the third level by starting with the initial value of the LFSR, and calling the algorithm three times, and so on. Now, if the player was to fail to produce STEP = 2 of the third level, the game should restart from the next value of the LFSR, so that we can produce a completely new sequence of steps. So, if the fourth level would have introduced the STEP, 4, we would now restart the game with a sequence of length 1, where the first step is 4. So think about how you can use this information to design a state machine that let’s you handle this logic, similar to the one I provided in Tutorial 11.

EXAMPLE CODE: 

MASK = 0xE2024CAB

BIT <- lsbit(STATE_LSFR)
STATE_LSFR <- STATE_LSFR >> 1
If (BIT = 1) 
	STATE_LSFR <- STATE_LSFR xor MASK
STEP <- STATE_LSFR and 0b11

#include <stdint.h>

// global state

// returns a random 2bit value 

T Function (void)
{
// modifies state 
// returns step 
}

{
//sequence of steps 
// step 1 [1]
// step 2 [1,2]
// step 3 [1,2,3]
}
{
// level 1:
// simon plays output corresponding to step = 1 

// player provides 1st input 
// the program checks if first input is correct 

// level 2: 
// simon plays output corresponding to step = 1 
// simon plays output corresponding to step = 2

// player provides 1st input 
// the program checks if first input is correct 
// player provides 2nd input 
// the program checks if first input is correct 

// level 3: 
// simon plays output corresponding to step = 1 
// simon plays output corresponding to step = 2
// simon plays output corresponding to step = 3

// player provides 1st input 
// the program checks if first input is correct 
// player provides 2nd input 
// the program checks if first input is correct 
// player provides 3rd input 
// the program checks if first input is correct 

}

{

// passing levels 1 and 2

// level 1:
// A -> 1 
// squiggly arrow to B

// level 2:
// A -> 1 
// squiggly arrow to B -> 2
	Squiggly arrow to C -> 3
		Squiggly arrow to D



}


Once you’ve setup the peripherals to produce outputs corresponding to the random values generated in Section B, you should think about how you will handle the gameplay mechanics. First, you should design a state machine that will help you write the code for this section, and you should look at how I designed the state machine in Tutorial 11, as a reference if you are unsure. When you are completing this section, try not to think about all aspects of the game at once, and instead focus on only one component at a time. In this section, we are only concerned with pushbutton inputs, and whether you can compare these with the sequence of steps played by Simon. When you’re implementing your state machine, make sure to upload your code to the QUTy board to quickly test if your code works as expected. And, once you’re satisfied with these results, upload your code to Gradescope to check if the emulator agrees with your results. Be mindful that the emulator will only press pushbuttons for 15 ms, so you’ll need to handle the requirement to produce an output for at least half the playback delay. Remember these tests will use a playback delay of 250 ms, so you can hardcode this value for now.

Once you have passed all the gameplay events, you can extend your program to handle a changing playback delay, based on the position of the potentiometer. If your program is efficient, this change should have no significant impact on the timing of events, as you’ll only be sampling the position of the potentiometer at the start of each level. Please refer to Tutorial 11 to see how to start conversions manually, and Tutorial 8 to see how to perform the mathematical conversion from the ADC value to the playback delay.

in this section, we're going to add functionality to handle UART communications for gameplay. This allows the user to input commands to the serial monitor, simulating button presses and other actions. Make sure you've already implemented the core gameplay mechanics before tackling this section as we'll be reusing some of that logic. To begin, UART must be configured to 9600 baud eight data bits, no parity and one stop bit, which is the default for Platform IO and the USART0 peripheral. If you're unsure how to do this, refer to Week nine Lectures and Week 11 studio, as well as tutorial 12 for a detailed UART communications setups. Also make sure to review serial passing using the Rx complete Interrupt as this will let us handle UART inputs in real time without blocking in the game. With that out of the way, let's look at the key mappings we would need to support for UART. Each command has two possible key mappings we could use. We would need to support this for each of our button presses, increasing, decreasing the frequency, handling a new seed input and restarting the game entirely. We'll walk through how to structure the UART communications in Pseudocode, focusing on how each key will map to gameplay actions. First, it's important that we set up the UART configuration in our code initialising the UART with settings that we talked about previously and also enabling the RX complete interrupt to handle incoming serial data. This RX complete interrupt allows us to receive serial input while the game runs without having to pause the program to wait the user input. This will be essential for keeping gameplay smooth and responsive. This is further covered in tutorial 12. Next is creating a serial interrupt handler through creating a state machine that handles the input as it comes through. The UART interface will allow each time a character is received to trigger a certain command. When a valid key is pressed, the corresponding game action is triggered keys like one through four simulate button presses and so on. Now, looking at the seed command, the seed key must be followed by exactly eight lower case hexadecimal digits. These digits will overwrite the seed for that random number generator, and the sequence generator after this must be based on the new seed. Keep a note that the seed command is only applied to the next game, whether after a win loss or reset, it should not reset the game from the current playing state. How you might want to do this is implementing a payload within your state machine. What we might want to do is check if the past result is valid. Check if it's invalid and additionally, check if the payload has received eight characters. If eight characters have been received, add the payload to the seed and reset it upon game completion. Now for the high score feature, this is used to track the top five high scoring games after a game concludes. If the user score qualifies as top score, they will be prompted to enter their name via UART. Note that users can only input a name of a maximum of 20 characters. If more than 20 characters are received, just take the 1st 20 characters. The name entry concludes when the user presses the enter key or if the user does not input anything Within five seconds, the name will be set to an empty string. If the user is entering a name while the seed command is being processed. The name entry takes priority. Once each UART functionality is implemented, make sure as usual to upload the code to your QUTy board and test the system by sending various commands through the serial interface. You should confirm that the button presses by the UART trigger the correct gameplay actions. Frequency adjustments via UART correctly change the buzzer's tone. The seed command works as expected, resetting the random sequence and high scores are transmitted over UART. After the game ends, make sure to remove any debugging printf statements or extra serial output before submitting your final version as they can slow down the program or cause unexpected behaviour. That's it for the UART implementation for section E. The key takeaway is that you should treat UART inputs similarly to pushbutton inputs and reuse existing game logic as much as possible. By keeping your code modular and efficient, you can easily integrate these additional features without adding unnecessary complexity


Now let's move on to the QUTy demonstration. In this demo, we will showcase the core gameplay mechanics, including sequence generation, user input handling and UART interactions on the QUTy board. In this section, the gameplay section, we define the sequence length starting at one, and it increases with each correct input, which is equal to the user's score. During Simon's turn, tones are played and segments on the seven segment display light up for each step in the sequence, followed by a playback delay. The user's job is to repeat Simon's sequence by pressing the corresponding buttons. If the user matches the sequence correctly, the score increases and the sequence length thus increases. If the user succeeds, the success pattern is displayed for the duration of the playback delay, with all segments illuminated. If they fail, the fail pattern is shown illuminating only the G segment, and the sequence resets to a length of one. The score is displayed on the seven segment display, showing values between zero and 99. Let's have a look at the gameplay for this device. On Reset, we know the sequence length will be set to one. So what this pretty much means is that when I reset this, it'll play one tone and one segment on the display, which is what can be seen. Now that the first sequence has been played. It is now the user's term. My job as the user is to make sure that I'm copying the same pattern that Simon has returned. So as because the tone on this segment lit up, I will press S1. As you've just seen, I got it correct, showing the success pattern for the full playback delay. After this, it is now Simon's turn again, incrementing the sequence length to 2 and playing the next two tones, which were here and here again, the same game applies. I copy the same two patterns that Simon gave me. It will return the success pattern and then play three tones in a row. Now what would this look like if I was to fail? Well, let's try if I press S4. What we expect is the fail pattern to display for the playback delay as well as the user score of three to display on the screen. What will happen now is for the next five seconds, it will expect a high score table, but you don't have to worry about this until you get to section E. So what I might explain now is that on user input, you should be playing for half the playback delay or for however long the user is holding it. If I hold down a button, it should play the tone and the segment until I let go, or until the playback delay is reached, whichever is bigger. As you can see, As I hold down this tone, it won't let go. And by this time, the elapsed time has passed. So when I let go, it will display the success pattern. One last thing is that if we were to fail, we should start with the next sequence. As we know on reset the first two segments are, this segment and this segment. So what should happen is if I reset the device. If I was to fail on the first attempt, the next sequence should start here, which it has done in this section. We use a pseudo random number generator to generate Simon's sequence. The seed for the pseudo random number generator is initialised with your student number converted into a 32 bit hexadecimal value. Each step in the sequence is derived from the state LSFR using the LSFR algorithm. For this following demonstration, I have set the sequence length to 20 to show how Simon should call the random number generator 20 times to produce 20 random outputs in this section. We're focusing on the playback delay, which controls how long Simon waits between steps in the sequence. The delay ranges from 0.25 to two seconds and is adjusted using the potentiometer. Turning the potentiometer clockwise will increase the delay while turning it anti clockwise will decrease it. The playback delay is calculated linearly, so if the potentiometer is positioned halfway, the delay will be exactly in the middle of this range. As you can see, if I turn the potentiometer fully clockwise and play the tone, it'll play for approximately half of two seconds. If I turn it around the other way, it will play for approximately half of 0.25 seconds. Somewhere in between will be somewhere in between 0.25 and two seconds, talking about section D. Now each four of your button presses will produce one of four tones as seen on screen, you will be able to calculate these off the last two digits of your student number by substitution In section E, we are integrating UART commands into the gameplay. First, we can simulate button presses using UART commands like 123 or 4. To represent the buttons, make sure to reuse your existing button press logic to handle this input efficiently for adjusting frequency. Make sure to use the appropriate UART commands to increase the tones frequency by one octave or decreasing it by one octave, either by multiplying by two or dividing by two. The seed command allows the user to input a new seed for the random sequence. This will reset the sequence generation based on the new seed, either on a loss win or on the reset button. The game can also be reset by Pressing Zero or R, which will reset the game to its initial state. Finally, the high score table will keep track of the top five scores, and it's important to follow the specification for formatting. Make sure you're outputting it exactly as required for this UART demonstration. What I'm going to do is run through each of the functionalities with the key mappings and showing it how it works on the device and through the serial monitor. To start off, how we might reset the device is by pressing zero or P. This resets all frequencies back to default and starts off off with a new game. So what I might do is press zero now to play the first tone. Now what I'm going to do is play some gameplay simulating the button presses just on my keyboard. So because the first one was S one, I know I can press either one or Q to simulate the button press, which I will now do. What happens is that because I was successful, the success word comes up, followed by the user score, both on new lines now because the next lot of sequences was one and three. I will copy again, displaying to success and the two. Now if I wanted to fail, so let's say I press four to simulate S4. It will show the game over and the final score also showing that. On the device what will happen now is it will wait for five seconds after five seconds. If no characters have been received, it will return an empty string with the user's score. What I might do now is to demonstrate the increased frequency and the decreased frequency. So, for example, if I wanted to increase, I could press the comma key by one, and this will increase my frequency. If I try and simulate this, what will happen? So you might be able to hear that the frequency has increased. If I press it one more time, it'll be increased again by double. What I might do now is to reduce it back to below. So if I press my dot key three times, I should be at a negative one octave. But press it again one more time. As you can see, these keys will increase or decrease the frequency, either by double or by a half. Now what I'll do is quickly. I'll press the reset key again. And what will happen is that if I try and play a little bit of the game, let's say now I forget what the pattern was and I press four. I might demonstrate here, so if I type my name in quickly. I can either press the enter key or wait five more seconds until it is simulated that I've pressed. Now that this has happened, we can see that my name appears with my score as well as the empty string and the user score. Just to reiterate, you only need to keep the five top scores in the high score table. The reset key should not reset the high score table at all. What I might simulate now is the seed key. So what I'll do is I'll press eight hexadecimal digits, which will overwrite the seed of the random number generator. What will happen is that this will only apply to the next game. So on a win or a loss or on the reset function. So what I'll do is I will go down and I will press the seed which is a nine, and I might input eight ones. So 12345678 Now the seed should have taken place. If I now press the reset key, we can see that it has now moved over to the fourth, generating a new seed from my base student number, which was 12345678. With this new seed of all ones, we can see that the game has now changed. As I progress through, we can see that the sequence has now completely changed off our base starting frequency.
