// tutorial11.c

#include <avr/io.h>
#include <avr/interrupt.h>

#include "buzzer.h"
#include "display_macros.h"
#include "initialisation.h"
#include "tut11_12.h"
#include "timer.h"

/** Tutorial 11

INTRODUCTION:

In this week's tutorial you will partially implement a reaction-time
game which will be controlled by the four pushbuttons on the QUTy.

The program randomly produces one of four values which correspond to a
unique output from both the buzzer and 7-segment display.

These outputs are described in the table below:

VALUE | Buzzer frequency | 7-segment display
------|------------------|------------------
    0 | 4XY * 2^(-5/12)  | Segments EF (LHS)
    1 | 4XY * 2^(-8/12)  | Segments BC (LHS)
    2 | 4XY              | Segments EF (RHS)
    3 | 4XY * 2^(-17/12) | Segments BC (RHS)

where XY are the last two digits of your student number.

The aim of this game is for the player to press the pushbutton
corresponding to these outputs, as quickly as possible.

To indicate that a pushbutton has been pressed by the player, the same
outputs will be produced.
*/

void state_machine(void);

int main(void)
{
    /** EX: 11.0

    TASK: Implement the following functions:

    - "buzzer_on" and "buzzer_off" in "buzzer.c".
    - "update_playback_delay" in "timer.c".
    */

    cli();
    adc_init();
    button_init();
    spi_init();
    pwm_init();
    timer_init();
    sei();

    state_machine();
}

void enable_outputs(uint8_t rng_index)
{
    /** EX: 11.1.1

    To promote modularity, we can write a function that enables the
    7-segment display and buzzer. The pattern and tone should correspond
    to either the random number generated by the program, or the input
    provided by the player.

    TASK: Use the functions "update_display" and "buzzer_on" to enable
    the outputs of the game based on the value passed to this function.
    The outputs produced by this function should correspond to the table
    above.

    NOTE: Several macros have been defined in "display_macros.h" to be
    used as inputs to the "update_display" function.

    To ensure timing is correct and fair, update the playback delay
    after all outputs have been enabled, and then reset the
    "elapsed_time" variable.
    */

    /** CODE: Write your code for Ex 11.1.1 within this function. */

    uint8_t idx = rng_index & 0x03;

    // Display mapping per table (bit7 must be clear for both params):
    // 0 -> Segments EF (LHS)
    // 1 -> Segments BC (LHS)
    // 2 -> Segments EF (RHS)
    // 3 -> Segments BC (RHS)
    switch (idx)
    {
    case 0:
        update_display(DISP_BAR_LEFT, DISP_OFF);
        break;
    case 1:
        update_display(DISP_BAR_RIGHT, DISP_OFF);
        break;
    case 2:
        update_display(DISP_OFF, DISP_BAR_LEFT);
        break;
    default: // 3
        update_display(DISP_OFF, DISP_BAR_RIGHT);
        break;
    }
    buzzer_on(idx);

    // playback time delay fairness 
    update_playback_delay();
    elapsed_time = 0;
}

void disable_outputs(void)
{
    /** EX: 11.1.2

    TASK: Use the functions "update_display" and "buzzer_off" to disable
    the 7-segment display and buzzer.
    */

    /** CODE: Write your code for Ex 11.1.2 within this function. */
    update_display(DISP_OFF, DISP_OFF);
    buzzer_off();
}

typedef enum
{
    GENERATE,
    PROMPT,

    INPUT_WAITING,
    INPUT_RECEIVED,
    INPUT_EVALUATE,

    DISPLAY_SUCCESS,
    DISPLAY_FAILURE
} state_t;

void state_machine(void)
{
    disable_outputs();

    /** EX: 11.2

    TASK: In the global scope we have declared an enumerated type (enum)
    that holds the values of each state required to implement the state
    machine in state_machine_tut11.png. Declare and initialise a
    variable of this type to store the initial state of the state
    machine.
    */

    state_t state = GENERATE;


    /** CODE: Write your code for Ex 11.2 above this line. */

    /** EX: 11.3

    A pseudo-random number generator (PRNG) has been implemented in
    "tut11_12.o", which is linked to this program. The function "rng"
    can be called to generate a 32-bit pseudo-random number.

    TASK: Initialise a variable called "seed" with a value equal to your
    student number, where each decimal digit in your student number
    represents a hexadecimal literal. Then, initialise the PRNG by
    calling the "set_seed" function.
    */

    uint32_t seed = 0x11993251u;
    set_seed(seed);
    // player input
    uint8_t input = 0;
    // player reaction time
    uint16_t reaction_time = 0;
    // pushbutton state
    uint8_t pb_previous_state, pb_current_state = 0xFF;
    // pushbutton edge flags (falling edge used for press detection)
    uint8_t pb_falling_edge = 0x00;
    // one-shot edge reset on INPUT_WAITING entry
    uint8_t pb_edge_reset_pending = 0u;


    /** CODE: Write your code for Ex 11.3 above this line. */

    while (1)
    {
        /** EX: 11.4

        TASK: Implement the state machine in state_machine_tut11.png.

        Each level of gameplay should call the "rng" function to
        generate a random number that will be used to prompt the player
        through the "enable_outputs" function you wrote above. The
        player must then match this prompt by pressing the corresponding
        pushbutton.

        As "rng" returns a 32-bit integer, inspect only the least
        significant two bits of this value.

        See the #include directives at the top of this file for
        available variables and functions.

        To determine a players reaction time, sample the "elapsed_time"
        variable when the 7-segment display and buzzer have finished
        producing an output, and when the player passes an input.

        Store the measured duration in "reaction_time" so that it can be
        used in Tutorial 12 when you setup UART.
        */

        /** CODE: Write your code for Ex 11.4 within this while loop. */

        if (pb_edge_reset_pending) {
            pb_previous_state = pb_debounced_state;
            pb_current_state  = pb_debounced_state;
            pb_falling_edge   = 0u;
            pb_edge_reset_pending = 0u;
        } else {
            pb_previous_state = pb_current_state;
            pb_current_state = pb_debounced_state;
            uint8_t pb_changed = pb_previous_state ^ pb_current_state;
            pb_falling_edge = pb_changed & pb_previous_state; 
        }

        static uint8_t prompt_idx = 0;

        switch (state)
        {
        case GENERATE:
        {
            disable_outputs();
            uint32_t r = rng();
            prompt_idx = (uint8_t)(r & 0x03u);
            enable_outputs(prompt_idx); 
            state = PROMPT;
            break;
        }
        case PROMPT:
        {
            // wait until the playback window completes
            if (elapsed_time >= playback_delay)
            {
                disable_outputs();
                elapsed_time = 0; // start reaction timer from now
                pb_edge_reset_pending = 1u; // ignore edges that occurred during prompt
                state = INPUT_WAITING;
            }
            break;
        }
        case INPUT_WAITING:
        {
            // check for any button press (falling edge)
            if (pb_falling_edge & PIN4_bm) { input = 0; }
            else if (pb_falling_edge & PIN5_bm) { input = 1; }
            else if (pb_falling_edge & PIN6_bm) { input = 2; }
            else if (pb_falling_edge & PIN7_bm) { input = 3; }
            else { break; }

            // indicate the players input and capture reaction time
            reaction_time = elapsed_time; // time since prompt finished
            enable_outputs(input);
            state = INPUT_RECEIVED;
            break;
        }
        case INPUT_RECEIVED:
        {
            // Briefly show users users input 
            if (elapsed_time >= playback_delay)
            {
                disable_outputs();
                state = INPUT_EVALUATE;
            }
            break;
        }
        case INPUT_EVALUATE:
        {
            if (input == prompt_idx)
            {
                // immediately show success and silence buzzer
                update_display(DISP_ON, DISP_ON);
                buzzer_off();
                elapsed_time = 0; // start success display timing
                state = DISPLAY_SUCCESS;
            }
            else
            {
                // immediately show failure and silence buzzer
                update_display(DISP_SEG_G, DISP_SEG_G);
                buzzer_off();
                elapsed_time = 0; // start failure display timing
                state = DISPLAY_FAILURE;
            }
            break;
        }
        case DISPLAY_SUCCESS:
        {
            // Hold success until timeout, then proceed to next round
            if (elapsed_time >= playback_delay)
            {
                disable_outputs();
                state = GENERATE;
            }
            break;
        }
        case DISPLAY_FAILURE:
        {
            // Show failure
            if (elapsed_time == 0)
            {
                update_display(DISP_SEG_G, DISP_SEG_G);
                buzzer_off();
            }
            if (elapsed_time >= playback_delay)
            {
                disable_outputs();
                state = GENERATE;
            }
            break;
        }
        default:
            state = GENERATE;
            break;
        }

        // suppress unused-variable warning that is blocking my gradescope from working...  for tut 12 
        (void)reaction_time;

    }
}
